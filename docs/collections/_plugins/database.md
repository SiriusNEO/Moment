---
title: Database - 数据库插件
nav_order: 2
---

# Database - 数据库插件

## 1. 简介

Database 插件为 Moment 提供原生的数据库功能支持。

为什么不使用一些第三方数据库（sqlite，sqlalchemy 等）？

- 首先我希望这个机器人非常 "轻"，我希望尽可能分离掉所有依赖到各个 Plugin 的自身 import 里。
- 其次，自己手写的数据库更符合自己的特殊需求，以及方便一些奇怪的 hack。
- 最后，群聊机器人其实数据量都不会太大，不采用任何数据结构的 `O(n)` for 循环也不会太慢，还方便了各种奇怪的匹配查询规则的实现。

## 2. 使用

数据库插件往往作为其它插件的依赖出现，它更多承担的是一个 "基本插件" 的角色。

### 2.1 数据库结构

Database 插件的数据库结构与许多类 SQL 数据库相似。

数据库整体 (称为一个**数据库**或者一个 **Database**) 是一个 `Python list`，其中每一项被称作数据库的**一行 (Line)**，也叫做一条**数据**。每个 Line 是一个 `Python dict`，拥有许多**字段 (Tag)**，有时也叫做数据库的**列 (Column)**。这个 `dict` 由 tag 名作为 key 值，value 值则称为**此 tag 条目的内容**。

例如对于一个学校的学生信息库来说，整个库就是一个 Database。其中，某条学生的信息数据就是一个 Line，比如：

```
id:12345678 name:路人甲 gender:男
```

这个 Line 包含了三个字段 `id`，`name`，`gender`，内容分别为 `12345678`,  `路人甲`,  `男`。

总得来说，数据库可用如下结构图简单表示：

```
Database: [Line1, Line2, ..., LineN]
- Line: 
  - tag1:value1 
  - tag2:value2 
  - tag3:value3
    - tag: str
    - value: any types (int, float, list, Message ...)
```

---

#### 2.1.1 特殊字段 id

不管是什么数据库，Moment 默认提供了一个字段 `id`，这个字段的数据类型是 `int`，意义是这条数据在数据库中的位置。

这一字段的值实际上并没有被真正储存，事实上，它是每次查询时根据某个 Line 在 Database 中的位置 (下标) 动态返回的。因此即使删除了中间的数据条目，也不会破坏 `id` 的连续性。

由于它的特殊性，你也不能对这一字段进行修改——任何尝试对它的修改都会发生报错。

### 2.2 数据库语言 - 总览

为了方便在聊天软件中打出使用，Moment 的数据库语言设计得非常简单而符号化。一个 Moment 数据库语句的结构可以被概括为：

```
[索引部分] 修改部分
```

{: .caution }
其中的 [ 和 ] 指左右方括号（中括号），是字面意义上要写在命令里的的字符。汉字部分是泛指，下面会细讲语法。

这是一个完整的语句，但并不意味着每条语句都要具有这些部分。事实上，这种简单的语句已经可以衍生出数据库最基本的 **CRUD**：

- 只有索引部分，即为 "查询"

  ```
  [索引部分]
  ```

- 只有修改部分，即为 "新建"

  ```
  修改部分
  ```

- 同时具有，即为 "修改"（索引部分负责指定修改对象，修改部分负责指定修改内容）

  ```
  [索引部分] 修改部分
  ```

设计上，CRUD 的第四个功能 "删除" 被作为一种特殊的修改存在。

### 2.3 数据库语言 - 索引部分

一个合法的索引部分应该具有如下形式：

```
[index1 index2 index3 ... indexN]
```

方括号是标志用字符，表示里面的东西作为一种 "捕获线索"（有一点点借鉴了 `C++` lambda 语法）。里面的 `index1` 、`index2` 等等被称为单个**索引 (index)**。所以一个索引部分即由两个中括号和中间一些用空格分割的索引组成。

我们通常说一个索引部分**锁定或匹配**某些数据。下面会解释锁定的规则。

---



#### 2.3.1 索引

一个索引应具有如下格式

```
<tag><op><value>
```

{: .caution }
此处这三者间不应该有空格。因为多个索引是通过空格分割的。

`tag` 表示条目。`op` 表示查询算符。`value` 表示一个值。合起来，这一个索引表示了一个限制。例如：

```
key=测试
```

这个索引里，`tag` 是 `key`，`op` 是 `=`，`value` 是 `测试`。由于 `=` 算符的意思是精确相等，那么这个索引的语义就是 "key 这一条目等于 '测试' 的所有数据"。

---



#### 2.3.2 查询符

即为上文所述的 `op`，目前 Moment 支持如下查询符：

| 符号      | 意义                                                         |
| --------- | ------------------------------------------------------------ |
| tag=value | tag 条目的内容与 value 精确相等。这需要此数据类型有 "等于" 的概念。 |
| tag?value | value 是 tag 条目的内容的子串。这需要此数据类型有 "子串" 的概念。一般是 Message。 |
| tag>value | tag 条目的内容比 value 严格大。这需要此数据类型有 "大于" 的概念。一般是数值类型。 |
| tag<value | tag 条目的内容比 value 严格小。这需要此数据类型有 "小于" 的概念。一般是数值类型。 |
| tag@value | tag 条目的内容是 value 的子串。这需要此数据类型有 "子串" 的概念。一般是 Message。 |

当数据库中某数据满足某个索引查询符的意义时，我们称这个索引**匹配**了这一数据，或这一数据被这一索引所匹配。

{: .caution }
有些时候 tag 可能是一个 list 类型。这需要 tag 条目中的每一个成员均满足此查询符的意义，此索引才算满足。

---



#### 2.3.3 锁定规则

索引可以有大等于零个。一个索引部分锁定或匹配的数据，指的是：

- 没有索引时，所有数据
- 单个索引时，该索引匹配的数据

- 多个索引时，被所有索引**共同匹配**的数据

注意多个索引的语义可以涵盖单个索引和零个索引的情况。我推荐可以把一个索引理解成 **"一个限制"**，限制越多能锁到的东西当然越少。

---



#### 2.3.4 特殊语法: 成员访问

我们知道一条数据包含了很多列，或者叫字段，或者叫成员。有时候，我们在锁定完数据后，想只关心某个字段。这时候，可以在最后面接上一个类似成员访问的语法：

```
[索引部分].tag
```

表示关心索引部分锁定的所有数据中的 `tag` 字段的内容。

严格上讲，`.tag` 也是索引部分的一员，不过鉴于比较特殊，在通式中就没有体现，放在这里特殊提醒一下。

---



#### 2.3.5 一个语法糖

大部分索引都需要具有

```
<tag><op><value>
```

的形式，除了一种情况，这也是 Moment 特地提供的一个语法糖：

```
<一个非负整数>
```

这相当于一个完全写开如下的索引

```
id=<非负整数>
```

例如，这个索引部分

```
[123]
```

表示锁定第 123 条数据。

由于这一索引能保证锁定的数据个数小等于 1，因此通常它是单独使用的。当然你也可以和其它索引一起使用来过滤掉更多信息。

### 2.4 数据库语言 - 查询语句

上面讲解了索引部分以及其锁定的规则。我们知道，只有索引部分的语句就是 Moment 数据库的查询语句，一个查询语句返回的就是其索引部分锁定的索引数据。因此，在这个语义下，我们有一个方便又优雅的**查询所有数据** (即没有任何限制) 的语句：

```
[]
```

再如，一个常用的查询语句：

```
[key?猫]
```

表示查询所有 `key` 字段中带猫的数据。

搭配成员访问的特殊语法，我们也可以很快地查到 "符合某些特征的群体的某一tag"。如：

```
[key=测试].cm
```

表示查询所有 `key` 字段为 "测试" 的数据的 `cm` 条目。

### 2.5 数据库语言 - 修改部分

一个合法的修改部分应该具有如下形式：

```
modify1 modify2 ... modifyN
```

其中每一项称为一个**修改 (Modify)**。此外，还有一种特殊的修改部分，它仅有一个指定命令构成：

```
<a special modify word>
```

下面分别来介绍。

---



#### 2.5.1 修改

"修改" 和前文提到的 "索引" 结构很像，也可以写作：

```
<tag><op><value>
```

这里的 `op` 被称作修改符。一个修改的意义是：将 `tag` 条目的内容，应用修改符 `op` 的规则，以 `value` 作为参数进行修改。例如：

```
key=测试
```

这一语句和 "索引" 中的例子看起来一样，但由于它是一个修改，所以解释起来的意思不一样。这里的 `=` 算符不再是 "精确相等"(因为这是一个查询符的意义)，而是作为修改符意思为 "赋值"。因此这一语句应解释为，把 `key` 字段的内容修改为 `测试`。

---



#### 2.5.2 修改符

目前 Moment 支持如下修改符：

| 符号      | 意义                                                         |
| --------- | ------------------------------------------------------------ |
| tag=value | 将 tag 条目的内容赋值为 value。需要数据类型有赋值的概念。    |
| tag+value | 在 tag 条目的内容下添加一个值为 value 的项。需要数据类型是一个集合体，如 list。 |
| tag-value | 在 tag 条目的内容下删去一个值为 value 的项。需要数据类型是一个集合体，如 list。 |

---



#### 2.5.3 修改命令

前面提到特殊修改命令只有一个**命令语句 (modify word)** 构成。目前 Moment 有如下两个特殊修改命令。

| 命令 | 意义                                    |
| ---- | --------------------------------------- |
| del  | 删除。                                  |
| clr  | 清空。需要数据类型有零值 / 空值的概念。 |

### 2.6 数据库语言 - 修改语句

前面提过，Moment 的修改语句如下：

 ```
[索引部分] 修改部分
 ```

已经分别介绍了这两部分的各自规则，那么我们就可以直接来描述修改语句的语义：它指的是，对于索引部分锁定的所有数据 (很多 Line)，分别应用修改部分的修改。例如：

```
[key=猫] key=狗
```

表示将所有 `key` 值为 `猫` 的 Line 的 `key` 改成 `狗`。

又如：

```
[] key=123
```

表示将所有数据的 `key` 值设为 `123`。

---



#### 2.6.1 特殊修改语句

前面提到了两种修改命令，在修改语句中，它们体现为：

```
[索引部分] del
```

删掉索引部分锁定的所有 Line。这里的删掉指的是从 Database 这个 list 中 remove。

```
[索引部分] clr
```

清空索引部分锁定的所有 Line。这里的清空指的是，将这个 Line 置为空字典 (没有任何 `tag`)。

---



#### 2.6.2 针对指定 tag 的特殊修改语句

我们之前提到，索引部分有一种特殊的语法，那就是

```
[索引部分].tag
```

搭配本节的特殊修改语句，可以做到对指定字段应用这些语句。分别讲就是：

```
[索引部分].tag del
```

删掉索引部分锁定的所有的 Line 中 `tag` 这一字段。这里的删掉指的是从 Line 字典中 把 `tag` 给 pop 掉。

```
[索引部分].tag clr
```

清空索引部分锁定的所有的 Line 中 `tag` 这一字段。这里的清空指的是将 Line 字典的 `tag` 对应值置为该数据类型的 "空值"。

{: .warning }

> 一个常见误区：有时候你可能会出现这样的误用
>
> ```
> [key=2].cm =3
> ```
>
> 虽然说乍看好像也有点那么个意思，但是这是不被 Moment 支持的。原因是这一语句的意思完全可以用如下语句代替：
>
> ```
> [key=2] cm=3
> ```
>
> 对于 `[key=2].cm` 的修改，Moment 只支持特殊修改语句，也就是修改命令（`del`，`clr`）的修改。

### 2.7 新建语句

新建语句是只有修改部分的语句：

```
修改部分
```

新建语句的语义是，创造一个新的 Line (初始为空字典)，然后对这个 Line 应用修改部分的修改。这其实某种程度上借鉴了 Python 的语法：第一次赋值是声明变量。

例如

```
key=测试1 cm=测试2
```

创建了一个 Line

```
key:测试1 cm:测试2
```

### 2.8 特殊指代词

#### 2.8.1 this

有时候，如果你的查询或者修改中 value 特别长，直接写在命令里会显得整条命令臃肿难看。一个推荐的方法是使用 Moment 提供的特殊指代词

```
%this
```

他的意义是，用你当前引用的信息 (Quote, a Message) 来代替命令中的 `%this`。这要求该字段的数据类型必须是 `Message` 或者 `List[Message]`。

例如

```
[key=%this]
---
引用的消息是: 哈哈哈
```

相当于

```
[key=哈哈哈]
```

---



#### 2.8.2 above

我们知道许多字段的数据类型是 List[Message] ，有时候你可能想要快速构造一个列表，但是使用 `+` 算符一个个添加很麻烦。这时候可以试试 Moment 提供的 `recording` + `%above` 机制 (感谢 [FeSO472](https://github.com/Feso472) 的设计)。

首先，要开始记录，使用一个特制命令

```
recording
```

 提醒机器人进入收集消息模式。接下来，机器人就会收集任何群聊中的非命令消息。

然后当需要时，直接使用 `%above` 指代词替代收集到的所有信息。例如你想快速做一个骰子

```
user: recording
user: 1
user: 2
user: 3
user: 4
user: 5
user: 6
user: pool=骰子 cm=%above
bot: 添加成功
```

查看后可以发现创建了

```
pool=骰子 cm=[1, 2, 3, 4, 5, 6]
```



## 3. 一些常用语句

```
[]
```

查看所有数据。



```
[] del
```

删除所有数据。



```
[cm=%this]
```

常用的反向查找。



```
[key=Appel] key=Apple
```

批量改正一个笔误。



```
[key?关键词]
```

关键词查找。



```
[key@%this]
```

查找引用的话带了哪些数据库中的关键词。

## 4. 注意事项

- 数据库的储存统一采用 `json` 格式。

- 数据库默认储存在 `local/` 目录下的某些位置。图片单独存在 `local/img` 下，采用数据与索引分离的方式；文字信息直接储存在 `json` 之中。